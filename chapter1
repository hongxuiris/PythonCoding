
#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
####################### Chapter 1 : Data Structure and String Manipulation

## chapter 1.1 Main data structure
# Data structure: a specialized format to organize and store data.
# main data structures in Python : list, tuple, set, dictionary

# list: an ordered mutable sequence of items (e.g. numbers, strings and other objects)
my_list = [1,2,3,4,5]
print(my_list)
print(my_list[2]) # 3 (indexing from 0)
print(my_list[-1]) # negative index, counting workd backwards in the list
print(my_list[1:4])  # access sub-list via slicing
print(my_list[2:]) # not specify left/right side index results in the whole range into account

# modify list
my_list[2] = 30
my_list[:2] = [10, 20]

# methods
my_list = [10, 20, 30, 40, 50]
my_list_append(60) 
print(my_list) # [10, 20, 30, 40, 50, 60]
my_list.remove(60)
print(my_list) # [10, 20, 30, 40, 50]

# pop removes the last item from a list and returns its value
my_list.pop() # 50 
print(my_list) # [10, 20, 30, 40]
#count() counts the number of a certain item in a list
my_list.count(40)  #1


# tuple: an ordered immutable sequence of items (numbers, strings, etc.)
# immutable means we can't modify it
# create tuple by using ()
my_tuple = (1, 'apple','2', 'banana')
# create tuple by writting comma-seperated values
my_tuple = 1, 'apple','2', 'banana'
# modifying items in a tuple is not possible !!! will get TypeError


# set: an unordered collection with no duplicate items 
# unordered means there is no indexing for the constituent items
my_set = set([1,2,3,4,5])
my_set = set([1,1,1,2,3,4,5,5,5])
print(my_set) # {1,2,3,4,5}

# insert a new item to a set
my_set1 = set([1,2,3,4,5])
my_set2 = set([3,4,5,6,7])
my_set1.add(6)
print(my_set1) # {1,2,3,4,5,6}
my_set1.remove(6)
print(my_set1) # {1,2,3,4,5}

my_set1.union(my_set2) # {1,2,3,4,5,6,7}
my_set1.intersection(my_set2) # {3,4,5}
my_set1.difference(my_set2) # {1,2} items in set1 but not in set2


# dictionary: a collection of key value pairs where keys are unique and immutalbe 
# dictionary is unordered
# create dictionary with curly bracckets
fruits = {'apple':10, 'orange':6, 'banana': 9}

# dict() constructor with a list of tuples
fruits = dict([('apple', 1), ('orange',6), ('banana',9)])

# access by specifying the key
fruits['apple']

# raise KeyError is the key does not exist
fruits['grape'] # KeyError

# modifying values
fruits['apple'] = 20
# if key does not exist, the opporation creates a key-value pair
fruits['grape'] = 11

# methods
# items() # return key-value pairs
list(fruits.items()) # [('apple', 10), ('orange',6), ('banana',9)]
list(fruits.keys()) # ['apple', 'orange', 'banana']
list(fruits.values()) #[10,6,9]

# remove the last inserted key-value pair with the popitem() method
fruits.popitem('banana') # 9 returns the associated value

# operations on list, tuple, set and dictionary
len()
# in
2 in my_list/my_tuple/my_set/my_dict

############# ********************** exercise ***************************** #######################

#Let's imagine a situation: you went to the market and filled your baskets (basket1 and basket2) with fruits. You wanted to have one 
# of each kind but realized that some fruits were put in both baskets.
# Task 1. Your first task is to remove everything from basket2 that is already present in basket1.
# Task 2. After the removal it is reasonable to anticipate that one of the baskets might weigh more compared to the another (all 
# fruit kinds weight the same). Therefore, the second task is to transfer some fruits from a heavier basket to the lighter one to 
# get approximately the same weight/amount of fruits.

for fruit in basket2:
    if fruit in basket1:
        basket2.remove(fruit)
print('Basket 1: ' + str(basket1))
print('Basket 2: ' + str(basket2))

# Transfer fruits from basket1 to basket2
while len(basket1) > len(basket2):
    item_to_move = basket1.pop()
    basket2.append(item_to_move)

# (A∪(B∩C))−(D∩E)
# A.union(B.intersection(C)).difference(D.intersection(E))




